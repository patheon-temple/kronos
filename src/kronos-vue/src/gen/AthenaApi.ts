// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "AthenaApi.proto" (syntax proto3)
// tslint:disable
import { PantheonIdentity } from "./AthenaCommon";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message DoesUsernameExistRequest
 */
export interface DoesUsernameExistRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
}
/**
 * @generated from protobuf message DoesUsernameExistResponse
 */
export interface DoesUsernameExistResponse {
    /**
     * @generated from protobuf field: bool doesExist = 1;
     */
    doesExist: boolean;
}
/**
 * @generated from protobuf message GetUserByDeviceIdRequest
 */
export interface GetUserByDeviceIdRequest {
    /**
     * @generated from protobuf field: string deviceId = 1;
     */
    deviceId: string;
}
/**
 * @generated from protobuf message GetUserByIdRequest
 */
export interface GetUserByIdRequest {
    /**
     * @generated from protobuf field: bytes userId = 1;
     */
    userId: Uint8Array;
}
/**
 * @generated from protobuf message GetUserByUsernameRequest
 */
export interface GetUserByUsernameRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
}
/**
 * @generated from protobuf message CreateUserFromDeviceIdRequest
 */
export interface CreateUserFromDeviceIdRequest {
    /**
     * @generated from protobuf field: string deviceId = 1;
     */
    deviceId: string;
}
/**
 * @generated from protobuf message CreateUserFromUsernameRequest
 */
export interface CreateUserFromUsernameRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message VerifyPasswordRequest
 */
export interface VerifyPasswordRequest {
    /**
     * @generated from protobuf field: bytes userId = 1;
     */
    userId: Uint8Array;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message VerifyPasswordResponse
 */
export interface VerifyPasswordResponse {
    /**
     * @generated from protobuf field: bool isValid = 1;
     */
    isValid: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class DoesUsernameExistRequest$Type extends MessageType<DoesUsernameExistRequest> {
    constructor() {
        super("DoesUsernameExistRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DoesUsernameExistRequest>): DoesUsernameExistRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<DoesUsernameExistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoesUsernameExistRequest): DoesUsernameExistRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoesUsernameExistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DoesUsernameExistRequest
 */
export const DoesUsernameExistRequest = new DoesUsernameExistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoesUsernameExistResponse$Type extends MessageType<DoesUsernameExistResponse> {
    constructor() {
        super("DoesUsernameExistResponse", [
            { no: 1, name: "doesExist", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DoesUsernameExistResponse>): DoesUsernameExistResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doesExist = false;
        if (value !== undefined)
            reflectionMergePartial<DoesUsernameExistResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoesUsernameExistResponse): DoesUsernameExistResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool doesExist */ 1:
                    message.doesExist = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoesUsernameExistResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool doesExist = 1; */
        if (message.doesExist !== false)
            writer.tag(1, WireType.Varint).bool(message.doesExist);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DoesUsernameExistResponse
 */
export const DoesUsernameExistResponse = new DoesUsernameExistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserByDeviceIdRequest$Type extends MessageType<GetUserByDeviceIdRequest> {
    constructor() {
        super("GetUserByDeviceIdRequest", [
            { no: 1, name: "deviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserByDeviceIdRequest>): GetUserByDeviceIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserByDeviceIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserByDeviceIdRequest): GetUserByDeviceIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deviceId */ 1:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserByDeviceIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string deviceId = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetUserByDeviceIdRequest
 */
export const GetUserByDeviceIdRequest = new GetUserByDeviceIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserByIdRequest$Type extends MessageType<GetUserByIdRequest> {
    constructor() {
        super("GetUserByIdRequest", [
            { no: 1, name: "userId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserByIdRequest>): GetUserByIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<GetUserByIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserByIdRequest): GetUserByIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes userId */ 1:
                    message.userId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserByIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes userId = 1; */
        if (message.userId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetUserByIdRequest
 */
export const GetUserByIdRequest = new GetUserByIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserByUsernameRequest$Type extends MessageType<GetUserByUsernameRequest> {
    constructor() {
        super("GetUserByUsernameRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserByUsernameRequest>): GetUserByUsernameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserByUsernameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserByUsernameRequest): GetUserByUsernameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserByUsernameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetUserByUsernameRequest
 */
export const GetUserByUsernameRequest = new GetUserByUsernameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserFromDeviceIdRequest$Type extends MessageType<CreateUserFromDeviceIdRequest> {
    constructor() {
        super("CreateUserFromDeviceIdRequest", [
            { no: 1, name: "deviceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUserFromDeviceIdRequest>): CreateUserFromDeviceIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateUserFromDeviceIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserFromDeviceIdRequest): CreateUserFromDeviceIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deviceId */ 1:
                    message.deviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserFromDeviceIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string deviceId = 1; */
        if (message.deviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateUserFromDeviceIdRequest
 */
export const CreateUserFromDeviceIdRequest = new CreateUserFromDeviceIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserFromUsernameRequest$Type extends MessageType<CreateUserFromUsernameRequest> {
    constructor() {
        super("CreateUserFromUsernameRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUserFromUsernameRequest>): CreateUserFromUsernameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<CreateUserFromUsernameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserFromUsernameRequest): CreateUserFromUsernameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserFromUsernameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateUserFromUsernameRequest
 */
export const CreateUserFromUsernameRequest = new CreateUserFromUsernameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyPasswordRequest$Type extends MessageType<VerifyPasswordRequest> {
    constructor() {
        super("VerifyPasswordRequest", [
            { no: 1, name: "userId", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyPasswordRequest>): VerifyPasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = new Uint8Array(0);
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<VerifyPasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyPasswordRequest): VerifyPasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes userId */ 1:
                    message.userId = reader.bytes();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyPasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes userId = 1; */
        if (message.userId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.userId);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VerifyPasswordRequest
 */
export const VerifyPasswordRequest = new VerifyPasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyPasswordResponse$Type extends MessageType<VerifyPasswordResponse> {
    constructor() {
        super("VerifyPasswordResponse", [
            { no: 1, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyPasswordResponse>): VerifyPasswordResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isValid = false;
        if (value !== undefined)
            reflectionMergePartial<VerifyPasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyPasswordResponse): VerifyPasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isValid */ 1:
                    message.isValid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyPasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isValid = 1; */
        if (message.isValid !== false)
            writer.tag(1, WireType.Varint).bool(message.isValid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VerifyPasswordResponse
 */
export const VerifyPasswordResponse = new VerifyPasswordResponse$Type();
/**
 * @generated ServiceType for protobuf service AthenaApiGrpc
 */
export const AthenaApiGrpc = new ServiceType("AthenaApiGrpc", [
    { name: "CreateUserFromDeviceId", options: {}, I: CreateUserFromDeviceIdRequest, O: PantheonIdentity },
    { name: "CreateUserFromUsername", options: {}, I: CreateUserFromUsernameRequest, O: PantheonIdentity },
    { name: "GetUserByDeviceId", options: {}, I: GetUserByDeviceIdRequest, O: PantheonIdentity },
    { name: "GetUserById", options: {}, I: GetUserByIdRequest, O: PantheonIdentity },
    { name: "GetUserByUsername", options: {}, I: GetUserByUsernameRequest, O: PantheonIdentity },
    { name: "DoesUsernameExist", options: {}, I: DoesUsernameExistRequest, O: DoesUsernameExistResponse },
    { name: "VerifyPassword", options: {}, I: VerifyPasswordRequest, O: VerifyPasswordResponse }
]);
